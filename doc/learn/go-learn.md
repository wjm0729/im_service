    Go 语言使用关键字 func 声明函数，关键字后面紧跟着函数名、参数以及返回值。
    
    切片是一种实现了一个动态数组的引用类型, Go 语言里可以用切片来操作一组数据
    
    := 这个运算符用于声明一个变量，同时给这个变量赋予初始值, 编译器使用函数返回值的类型来确定每个变量的类型。
    简化变量声明运算符只是一 种简化记法，让代码可读性更高。这个运算符声明的变量和其他使用关键字 var 声明的变量没有任何区别。
    
    根据经验，如果需要声明初始值为零值的变量，应该使用 var 关键字声明变量;
    如果提供确切的非零值初始化变量或者使用函数返回 值创建变量，应该使用简化变量声明运算符( := )
    
    Goroutine是一个与其他goroutines 并发运行在同一地址空间的Go函数或方法。
    一个运行的程序由一个或更多个goroutine组成。它与线程、协程、进程等不同。它是一个goroutine
    
    使用关 键字 for range 对 feeds 切片做迭代
    for _, feed := range feeds {
        ...
    }
    
    关键字 range 可以用于迭代数组、字符串、切片、映射和通道 (array/string/slice/map/channel)
    使用 for range 迭代切片时，每次迭代会返回两个值。第一个值是迭代的元素在切 片里的索引位置，第二个值是元素值的一个副本
    
    // 启动一个 goroutine
    go func(参数描述) {
        // 并发逻辑
    }(入参)
    
    如果 要调用的函数返回多个值，而又不需要其中的某个值，就可以使用下划线标识符将其忽略。
    
    var matchers = make(map[string]Matcher)
    matcher, exists := matchers[feed.Type]
    查找 map 里的键时，有两个选择:
        要么赋值给一个变量
        要么为了精确查找, 赋值给两个变量。
            赋值给两个变量时第一个值和赋值给一个变量时的值一样，是 map 查找的结果值。
            如果指定了第二个值，就会返回一个布尔标志，来表示查找的键是否存在于 map 里。
            如果这个键不存在，map 会返回其值类型的零值作为返回值，如果这个键存在，map 会返回键所对应值的副本。
    
    
    Go 语言里的引用类型有如下几个: 切片、映射、通道、接口和函数类型。
    数组是值类型
    slice是引用类型(注意: slice的 append 方法有点坑)
    
    指针变量可以方便地在函数之间共享数据。使用指针变量可以让函数访问并修改一个变 量的状态，
    而这个变量可以在其他函数甚至是其他 goroutine 的作用域里声明。
    
    在 Go 语言中，所有的变量都以值(指针的值就是其地址)的方式传递。
    
    所有的 goroutine 都会因为闭包共享同样的变量。除非我们以函数参数的形式传值给匿名函数.
    
    因为 Go 编译器可以根据赋值运算符右边的值来推导类型，声明[常量]的时候不需要指定类型。
    
    常量的名称使用小写字母开头，表示它只能在自身包内的代码里直接访问，而不暴露到包外面。
    
    error 类型值来表示函数是否调用成功
    
    关键字 defer 会安排随后的函数调用在函数返回时才执行。(类似于 java 的 finally)
    使用关键字 defer 来安排调用 Close 方法，可以保证这个函数一定会被调用。
    哪怕函数意外崩溃终止，也能保证关键字 defer 安排调用的函数会被执行。
    
    interface{} 表示任意类型, 类似于 java 的 Object
    
    Go 语言的命名惯例。如果接口类型只包含一个方法，那么这 个类型的名字以 er 结尾。
    
    如果要让一个用户定义的类型实现一个接口，这个用户定义的类型要实现接口类型里声明的[所有]方法。
    
    空结构在创建实例时，不会分配任何内存。这种结构很适合创建没有任何状态的类型。
    
    
    // 定义类型的方法
    func (m rssMatcher) Search(feed *search.Feed, searchTerm string) ([]*search.Result, error) {
        ...
    }
    如果声明函数的时候带有[接收者]，则意味着声明了一个方法。这个方法会和指定的[接收者]的[类型]绑在一起。
    无论我们是使用接收者类型的[值]来调用这个方，还是使用接收者类型值的[指针]来调用这个方法，
    编译器都会正确地引用或者解引用对应的值，作为接收者传递给被调用的方法.
    
    // 方法声明为使用 defaultMatcher 类型的值作为接收者
    func (m defaultMatcher) Search(feed *Feed, searchTerm string)
    // 声明一个指向 defaultMatcher 类型值的指针 
    dm := new(defaultMatch)
    // 编译器会解开 dm 指针的引用，使用对应的值调用方法 
    dm.Search(feed, "test")
    
    // 方法声明为使用指向 defaultMatcher 类型值的指针作为接收者
    func (m *defaultMatcher) Search(feed *Feed, searchTerm string)
    // 声明一个 defaultMatcher 类型的值 
    var dm defaultMatch
    // 编译器会自动生成指针引用 dm 值，使用指针调用方法 
    dm.Search(feed, "test")
    
    =========================================================
    因为大部分方法在被调用后都需要维护接收者的值的状态，所以，一个最佳实践是，将方法的接收者声明为指针。
    即上面的第二种写法
    =========================================================
    
    =========================================================
    使用指针作为接收者声明的方法，只能在接口类型的值是一个指针的时候被调用。
    使用值作为接收者声明的方法，在接口类型的值为值或者指针时，都可以被调用。
    =========================================================
    
    行导入包，这让编译器可以找到 default.go 代码文件里的 init 函数。
    一旦编译器发现 init 函数，它就会给这个函数优先执行的权限，保证其在 main 函数之前被调用。
    使用 init 函数可以非常完美地完成这种初始化时注 册的任务。
    
    我们使用下划线标识符作为别名导入, 这种方法可以让编译器在导入未被引用的包时不报错，而且依旧会定位到包内的 init 函数。
    
    
    我们使用 fmt 包里的 Errorf 函数 返回一个自定义的错误
    
    所有用 Go 语言编译的可执行程序都必须有一个名叫 main 的包。
    
    当编译器发现某个包的名字为 main 时，它一定也会发现名为 main()的函数，否则不会创建可执行文件。
    程序编译时，会使用声明 main 包的代码所在的目录的目录名作为二进制可执行文件的文件名。
    
    编译器会首先查找 Go 的安装目录，然后才会按顺序查找 GOPATH 变量里列出的目录。
    
    每个包可以包含任意多个 init 函数，这些函数都会在程序执行开始的时候被调用。
    所有被 编译器发现的 init 函数都会安排在 main 函数之前执行。
    init 函数用在设置包、初始化变量 或者其他要在程序运行前优先完成的引导工作。
    
    --------------------------------------------------------------------------------------------------------------------
    
    Go 语言里的引用类型有如下几个:切片、映射、通道、接口和函数类型。当声明上述类型的变量时，创建的变量被称作标头(header)值。
    
    *****没太懂*****
    每个引用类型还包含一组独特 的字段，用于管理底层数据结构。因为标头值是为复制而设计的，所以永远不需要共享一个引用 类型的值。
    标头值里包含一个指针，因此通过复制来传递一个引用类型的值的副本，本质上就是 在共享底层数据结构。
    
    当要围绕相关的内 置类型或者引用类型来声明用户定义的行为时，直接基于已有类型来声明用户定义的类型会很好 用。编译器只允许为命名的用户定义的类型声明方法
    如: 
        type IP []byte
    
    引用 类型的值在其他方面像原始的数据类型的值一样对待。
    
    方法集定义了一组关联到给定类型的值或者指针的方法。
    定义方法时使用的接收者的类型决 定了这个方法是关联到值，还是关联到指针，还是两个都关联。
    
    Methods     Receivers Values 
    -----------------------------------------------
    (t T)       T and *T 
    (t *T)      *T
    这个规则说，如果使用指针接收者来实现一个接口，那么只有指向那个类型的指针才能够实现对应的接口。
    如果使用值 接收者来实现一个接口，那么那个类型的值和指针都能够实现对应的接口。
    
    嵌入类型
    // user在程序里定义一个用户类型 
    type user struct {
        name string
        email string
    }
    
    // admin代表一个拥有权限的管理员用户
    type admin struct {
        user // 嵌入类型
        level string
    }
    
    通过嵌入类型，与内部类型相关的标识符会提升到外部类型上。
    这些被提升的标识符就像直接声明在外部类型里的标识符一样，也是外部类型的一部分。
    这样外部类型就组合了内部类型包含的所有属性，并且可以添加新的字段和方法。
    外部类型也可以通过声明与内部类型标识符同名的标识符来覆盖内部标识符的字段或者方法。这就是扩展或者修改已有类型的方法。
    
    要嵌入一个类型，只需要声明这个类型的名字就可以了。
    
    
     使用关键字 struct 或者通过指定已经存在的类型，可以声明用户定义的类型。
     方法提供了一种给用户定义的类型增加行为的方式。
     设计类型时需要确认类型的本质是原始的，还是非原始的。
     接口是声明了一组行为并支持多态的类型。 
     嵌入类型提供了扩展类型的能力，而无需使用继承。 
     标识符要么是从包里公开的，要么是在包里未公开的。
    
    
    ==========================================================================================
    ==========================================================================================
    ==========================================================================================
    ==========================================================================================
    
    Go 语言 运行时的调度器是一个复杂的软件，能管理被创建的所有 goroutine 并为其分配执行时间。
    这个调度 器在操作系统之上，将操作系统的线程与语言运行时的逻辑处理器绑定，并在逻辑处理器上运行 goroutine。
    调度器在任何给定的时间，都会全面控制哪个 goroutine 要在哪个逻辑处理器上运行。
    
    
    有时，正在运行的 goroutine 需要执行一个阻塞的系统调用，如打开一个文件。
    当这类调用 发生时，线程和 goroutine 会从逻辑处理器上分离，该线程会继续阻塞，等待系统调用的返回。 
    与此同时，这个逻辑处理器就失去了用来运行的线程。所以，调度器会创建一个新线程，并将其 绑定到该逻辑处理器上。
    之后，调度器会从本地运行队列里选择另一个 goroutine 来运行。
    一旦 被阻塞的系统调用执行完成并返回，对应的 goroutine 会放回到本地运行队列，而之前的线程会保存好，以便之后可以继续使用。
    
    如果一个 goroutine 需要做一个网络 I/O 调用，流程上会有些不一样。在这种情况下，goroutine 会和逻辑处理器分离，并移到集成了网络轮询器的运行时。
    一旦该轮询器指示某个网络读或者写 操作已经就绪，对应的 goroutine 就会重新分配到逻辑处理器上来完成操作。
    调度器对可以创建 的逻辑处理器的数量没有限制，但语言运行时默认限制每个程序最多创建 10 000 个线程。
    这个 限制值可以通过调用 runtime/debug 包的 SetMaxThreads 方法来更改。如果程序试图使用 更多的线程，就会崩溃。
    
    并行的关键是同时做很多事情，而并发是指同时管理很多事情，这些事情可能只做 了一半就被暂停去做别的事情了。
    
    ##goroutine的内部调度可能是根据时间片来分配的, 类似于 CPU 的调度算法##
   
    Go 语言提供了传统的同步 goroutine 的机制，就是对共享资源加锁。
    如果需要顺序访问一个 整型变量或者一段代码，atomic 和 sync 包里的函数提供了很好的解决方案。
   
### 无缓冲的通道(unbuffered channel)
    是指在接收前没有能力保存任何值的通道。这种类型的通 道要求发送 goroutine 和接收 goroutine 同时准备好，才能完成发送和接收操作。
    如果两个 goroutine 没有同时准备好，通道会导致先执行发送或接收操作的 goroutine 阻塞等待。
    这种对通道进行发送 和接收的交互行为本身就是同步的。其中任意一个操作都无法离开另一个操作单独存在。
    
### 有缓冲的通道(buffered channel)
    是一种在被接收前能存储一个或者多个值的通道。这种类型的通道并不强制要求 goroutine 之间必须同时完成发送和接收。
    通道会阻塞发送和接收动作的条件也会不同。
    *只有在通道中没有要接收的值时，接收动作才会阻塞。
    *只有在通道没有可用缓冲区容纳被发送的值时，发送动作才会阻塞。
    这导致有缓冲的通道和无缓冲的通道之间的一个很大的不同:
    无缓冲的通道保证进行发送和接收的 goroutine 会在同一时间进行数据交换;
    有缓冲的通道没有这种保证。
    
    
     并发是指 goroutine 运行的时候是相互独立的。
     使用关键字 go 创建 goroutine 来运行函数。
     goroutine 在逻辑处理器上执行，而逻辑处理器具有独立的系统线程和运行队列。 
     竞争状态是指两个或者多个 goroutine 试图访问同一个资源。 
     原子函数和互斥锁提供了一种防止出现竞争状态的办法。 
     通道提供了一种在两个 goroutine 之间共享数据的简单方法。
     无缓冲的通道保证同时交换数据，而有缓冲的通道不做这种保证。
    
    
    无缓冲的通道保证两个 goroutine 之间的数据交换。
    这种使用无缓冲的通道的方法允许使用 者知道什么时候 goroutine 池正在执行工作，而且如果池里的所有 goroutine 都忙，
    无法接受新的 工作的时候，也能及时通过通道来通知调用者。
    使用无缓冲的通道不会有工作在队列里丢失或者 卡住，所有工作都会被处理。
    
    
     可以使用通道来控制程序的生命周期。
     带 default 分支的 select 语句可以用来尝试向通道发送或者接收数据，而不会阻塞。
     有缓冲的通道可以用来管理一组可复用的资源。
     语言运行时会处理好通道的协作和同步。
     使用无缓冲的通道来创建完成工作的 goroutine 池。 
     任何时间都可以用无缓冲的通道来让两个 goroutine 交换数据，在通道操作完成时一定保证对方接收到了数据。
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
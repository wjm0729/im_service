    Go 语言使用关键字 func 声明函数，关键字后面紧跟着函数名、参数以及返回值。
    
    切片是一种实现了一个动态数组的引用类型, Go 语言里可以用切片来操作一组数据
    
    := 这个运算符用于声明一个变量，同时给这个变量赋予初始值, 编译器使用函数返回值的类型来确定每个变量的类型。
    简化变量声明运算符只是一 种简化记法，让代码可读性更高。这个运算符声明的变量和其他使用关键字 var 声明的变量没有任何区别。
    
    根据经验，如果需要声明初始值为零值的变量，应该使用 var 关键字声明变量;
    如果提供确切的非零值初始化变量或者使用函数返回 值创建变量，应该使用简化变量声明运算符( := )
    
    Goroutine是一个与其他goroutines 并发运行在同一地址空间的Go函数或方法。
    一个运行的程序由一个或更多个goroutine组成。它与线程、协程、进程等不同。它是一个goroutine
    
    使用关 键字 for range 对 feeds 切片做迭代
    for _, feed := range feeds {
        ...
    }
    
    关键字 range 可以用于迭代数组、字符串、切片、映射和通道 (array/string/slice/map/channel)
    使用 for range 迭代切片时，每次迭代会返回两个值。第一个值是迭代的元素在切 片里的索引位置，第二个值是元素值的一个副本
    
    // 启动一个 goroutine
    go func(参数描述) {
        // 并发逻辑
    }(入参)
    
    如果 要调用的函数返回多个值，而又不需要其中的某个值，就可以使用下划线标识符将其忽略。
    
    var matchers = make(map[string]Matcher)
    matcher, exists := matchers[feed.Type]
    查找 map 里的键时，有两个选择:
        要么赋值给一个变量
        要么为了精确查找, 赋值给两个变量。
            赋值给两个变量时第一个值和赋值给一个变量时的值一样，是 map 查找的结果值。
            如果指定了第二个值，就会返回一个布尔标志，来表示查找的键是否存在于 map 里。
            如果这个键不存在，map 会返回其值类型的零值作为返回值，如果这个键存在，map 会返回键所对应值的副本。
    
    
    Go 语言里的引用类型有如下几个: 切片、映射、通道、接口和函数类型。
    数组是值类型
    slice是引用类型(注意: slice的 append 方法有点坑)
    
    指针变量可以方便地在函数之间共享数据。使用指针变量可以让函数访问并修改一个变 量的状态，
    而这个变量可以在其他函数甚至是其他 goroutine 的作用域里声明。
    
    在 Go 语言中，所有的变量都以值(指针的值就是其地址)的方式传递。
    
    所有的 goroutine 都会因为闭包共享同样的变量。除非我们以函数参数的形式传值给匿名函数.
    
    因为 Go 编译器可以根据赋值运算符右边的值来推导类型，声明[常量]的时候不需要指定类型。
    
    常量的名称使用小写字母开头，表示它只能在自身包内的代码里直接访问，而不暴露到包外面。
    
    error 类型值来表示函数是否调用成功
    
    关键字 defer 会安排随后的函数调用在函数返回时才执行。(类似于 java 的 finally)
    使用关键字 defer 来安排调用 Close 方法，可以保证这个函数一定会被调用。
    哪怕函数意外崩溃终止，也能保证关键字 defer 安排调用的函数会被执行。
    
    interface{} 表示任意类型, 类似于 java 的 Object
    
    Go 语言的命名惯例。如果接口类型只包含一个方法，那么这 个类型的名字以 er 结尾。
    
    如果要让一个用户定义的类型实现一个接口，这个用户定义的类型要实现接口类型里声明的[所有]方法。
    
    空结构在创建实例时，不会分配任何内存。这种结构很适合创建没有任何状态的类型。
    
    
    // 定义类型的方法
    func (m rssMatcher) Search(feed *search.Feed, searchTerm string) ([]*search.Result, error) {
        ...
    }
    如果声明函数的时候带有[接收者]，则意味着声明了一个方法。这个方法会和指定的[接收者]的[类型]绑在一起。
    无论我们是使用接收者类型的[值]来调用这个方，还是使用接收者类型值的[指针]来调用这个方法，
    编译器都会正确地引用或者解引用对应的值，作为接收者传递给被调用的方法.
    
    // 方法声明为使用 defaultMatcher 类型的值作为接收者
    func (m defaultMatcher) Search(feed *Feed, searchTerm string)
    // 声明一个指向 defaultMatcher 类型值的指针 
    dm := new(defaultMatch)
    // 编译器会解开 dm 指针的引用，使用对应的值调用方法 
    dm.Search(feed, "test")
    
    // 方法声明为使用指向 defaultMatcher 类型值的指针作为接收者
    func (m *defaultMatcher) Search(feed *Feed, searchTerm string)
    // 声明一个 defaultMatcher 类型的值 
    var dm defaultMatch
    // 编译器会自动生成指针引用 dm 值，使用指针调用方法 
    dm.Search(feed, "test")
    
    =========================================================
    因为大部分方法在被调用后都需要维护接收者的值的状态，所以，一个最佳实践是，将方法的接收者声明为指针。
    即上面的第二种写法
    =========================================================
    
    =========================================================
    使用指针作为接收者声明的方法，只能在接口类型的值是一个指针的时候被调用。
    使用值作为接收者声明的方法，在接口类型的值为值或者指针时，都可以被调用。
    =========================================================
    
    行导入包，这让编译器可以找到 default.go 代码文件里的 init 函数。
    一旦编译器发现 init 函数，它就会给这个函数优先执行的权限，保证其在 main 函数之前被调用。
    使用 init 函数可以非常完美地完成这种初始化时注 册的任务。
    
    我们使用下划线标识符作为别名导入, 这种方法可以让编译器在导入未被引用的包时不报错，而且依旧会定位到包内的 init 函数。
    
    
    我们使用 fmt 包里的 Errorf 函数 返回一个自定义的错误
    
    所有用 Go 语言编译的可执行程序都必须有一个名叫 main 的包。
    
    当编译器发现某个包的名字为 main 时，它一定也会发现名为 main()的函数，否则不会创建可执行文件。
    程序编译时，会使用声明 main 包的代码所在的目录的目录名作为二进制可执行文件的文件名。
    
    编译器会首先查找 Go 的安装目录，然后才会按顺序查找 GOPATH 变量里列出的目录。
    
    每个包可以包含任意多个 init 函数，这些函数都会在程序执行开始的时候被调用。
    所有被 编译器发现的 init 函数都会安排在 main 函数之前执行。
    init 函数用在设置包、初始化变量 或者其他要在程序运行前优先完成的引导工作。
    
    
    
    
    
    
    
    
    
    
    